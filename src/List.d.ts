export declare function add<T>(xs: T[], ys: T[]): T[];
export declare function head<T>(xs: T[]): T;
export declare function last<T>(xs: T[]): T;
export declare function tail<T>(xs: T[]): T[];
export declare function init<T>(xs: T[]): T[];
export declare function map<A, B>(f: (x: A) => B, xs: A[]): B[];
export declare function reverse<T>(xs: T[]): T[];
export declare function intersperse<T>(x: T, xs: T[]): T[];
export declare function intercalate<T>(xs: T[], xss: T[][]): T[];
export declare function foldl<A, B>(f: (acc: B, x: A) => B, initial: B, xs: A[]): B;
export declare function foldr<A, B>(f: (x: A, acc: B) => B, initial: B, xs: A[]): B;
export declare function concat<T>(xss: T[][]): T[];
export declare function sum(xs: number[]): number;
export declare function product<T>(xs: number[]): number;
export declare function sort<T>(xs: T[], compare: (a: T, b: T) => number): T[];
export declare function sortInPlace<T>(xs: T[], compare: (a: T, b: T) => number): T[];
export declare function maximumInRange<T>(xs: T[], s: number, e: number): T;
export declare function maximum<T>(xs: T[]): T;
export declare function maximumInRangeWith<T, R>(xs: T[], s: number, e: number, f: (x: T) => R): R;
export declare function maximumWith<T, R>(xs: T[], f: (x: T) => R): R;
export declare function minimumInRange<T>(xs: T[], s: number, e: number): T;
export declare function minimum<T>(xs: T[]): T;
export declare function minimumInRangeWith<T, R>(xs: T[], s: number, e: number, f: (x: T) => R): R;
export declare function minimumWith<T, R>(xs: T[], f: (x: T) => R): R;
export declare function replicate<T>(n: number, x: T): T[];
export declare function take<T>(n: number, xs: T[]): T[];
export declare function drop<T>(n: number, xs: T[]): T[];
export declare function splitAt<T>(n: number, xs: T[]): [T[], T[]];
export declare function takeWhile<T>(f: (x: T) => boolean, xs: T[]): T[];
export declare function dropWhile<T>(f: (x: T) => boolean, xs: T[]): T[];
export declare function group<T>(xs: T[]): T[][];
export declare function nub<T>(xs: T[]): T[];
export declare function filter<T>(f: (x: T) => boolean, xs: T[]): T[];
export declare function zip<A, B>(xs: A[], ys: B[]): [A, B][];
export declare function unzip<A, B>(xs: [A, B][]): [A[], B[]];
export declare function range(from: number, to: number): number[];
export declare function copy<A>(xs: A[]): A[];
export declare function apply_permutation<A>(p: number[], xs: A[]): A[];
export declare function next_permutation(p: number[]): number[];
export declare function create<T>(n: number, value: T): T[];
export declare function createWith<T>(n: number, f: (i: number) => T): T[];
export declare function create2D<T>(n1: number, n2: number, value: T): T[][];
export declare function create2DWith<T>(n1: number, n2: number, f: (i: number, j: number) => T): T[][];
